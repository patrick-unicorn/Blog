---
author: "patrick.unicorn"
output:
  html_document:
    css: ../../css/main.css
    highlight: null
    theme: null
---

读《Java Performance: The Definitive Guide》

* * *

+ JVM 性能调优的过程实际上与 C++ 程序员在编译时通过测试选择编译参数，以及 PHP 码农在 php.ini
文件中选择适当变量等过程非常类似。

+ 编码和调优常常被认为是两个不同的专业领域：性能调优工程师只是竭力将 JVM 的性能发挥到极致，而开发人员只关心他们的代码逻辑是否正确。这种区分没有什么意义。任何从事Java相关工作的人都应该熟谙代码在 JVM 中的行为，以及如何调优才能提升性能。

+ 商业版 JVM 中和性能密切相关的一个特性就是 Java 飞行记录器（Java Flight Recorder，JFR）。

+ 除了少数例外，JVM 主要接受两类标志：布尔标志和附带参数的标志。

+ 布尔标志采用以下语法： -XX:+FlagName 表示开启， -XX:-FlagName 表示关闭。

+ 附带参数的标志采用以下语法： -XX:FlagName=something ，表示将标志 flagName 的值设置为 something 。其中 something 通常可以为任意值。例如 -XX:NewRatio=N ，表示 NewRatio可以设置为任意值 N。

+ 在给定的命令行上，添加 -XX:+Printflagsfinal （默认为 false ，即“关闭” ）就能获得具体运行环境中特定标志的默认值。

+ 需要更高性能时，算法是否优秀就是重中之重了。

+ 要创建和销毁的对象越多，垃圾收集的工作量就越大；要分配和持有的对象越多，GC 的周期就越长；要从磁盘装载进 JVM 的类越
多，程序启动所花费的时间就越长；要执行的代码越多，机器硬件缓存的效率就越低；而执行的代码越多，花费的时间就越长。

+ 随着新特性的添加和新要求的采纳（为了与对手竞争） ，程序会越来越大，越来越慢。

+ “我们不应该把大量时间都耗费在那些小的性能改进上；过早考虑优化是所有噩梦的根源” 。这句名言的重点是，最终你应该编写清晰、直接、易读和易理解的代码。这里的“优化”应该理解为虽然算法和设计改变了复杂程序的结构，但是提供了更好的性能。那些真正的优化最好留到以后，等到性能分析表明这些措施有巨大收益的时候才进行。而这里所指的过早优化，并不包括避免那些已经知道对性能不好的代码结构。每行代码，如果有两种简单、直接的编程方式，那就应该选择性能更好的那种。

+ 常用的打印日志中，如果有拼接字符串的消息，应该首先判断日志是否开启，以避免不必要的字符串连接开销，比如：

```
// 不好
log.log(Level.FINE, "I am here, and the value of X is" 
    + calcX() + " and Y is " + calcY());
    
// 优化
if (log.isLoggable(Level.FINE)) {
    log.log(Level.FINE,
        "I am here, and the value of X is {} and Y is {}",
        new Object[]{calcX(), calcY()});
}
```

+ 在分布式环境中，比如 Java EE 应用服务器、负载均衡器、数据库和后台企业信息系统，Java 应用服务
器的性能问题可能只是其中很小的部分。

+ 对于整体系统，我们需要采取结构化方法针对系统的所有方面分析性能。CPU使用率、I/O延迟、系统整体的吞吐量都必须测量和分析。只有到那时，我们才能判定到底是哪个组件导致了性能瓶颈。

+ 增加系统某个组件的负载从而导致整个系统性能变慢，这项原则不仅限于数据库。CPU密集型的应用服务器增加负载，或者越来越多线程试图获取已经有线程等待的锁，还有许多其他场景，也都适用这项原则。

+ 优化的原则：

<blockquote>
+ 借助性能分析来优化代码，重点关注性能分析中最耗时的操作。然而请注意，这并不意
味着只看性能分析中的叶子方法 。

+ 利用奥卡姆剃刀原则诊断性能问题。性能问题最可能的原因应该是最容易解释的：新代
码比机器配置更可能引入性能问题，而机器配置比 JVM 或者操作系统的 bug 更容易引
入性能问题。隐藏的 bug 确实存在，但不应该把最可能引起性能问题的原因首先归咎于
它，而只在测试用例通过某种方式触发了隐藏的 bug 时才关注。但不应该一上来就跳到
这种不太可能的场景。

+ 为应用中最常用的操作编写简单算法。以估算数学公式的程序为例，用户可以决定他所
期望的最大容许误差为 10% 或 1%。如果 10% 的误差适合多数用户，那么优化代码就
意味着即便误差范围缩小为 1%，但是速度变慢了
</blockquote>

+ **微基准测试**用来测量微小代码单元的性能，包括调用同步方法的用时与非同步方法的用时比较，创建线程的代价与使用线程池的代价，执行某种算法的耗时与其替代实现的耗时，等等。相当于测试函数或代码片段。
