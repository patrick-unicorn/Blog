---
author: "patrick.unicorn"
output:
  html_document:
    css: ../css/main.css
    highlight: null
    theme: null
---

读《A Little Java A Few Pattern》
===

* * *

本文的目的不在于翻译《A Little Java A Few Pattern》，而在于对书中比较”怪异、晦涩”的代码片段进行解读。如果对本书感兴趣，可以移步[这里][1]。


[1]: http://a-little-java-a-few-patterns.readthedocs.io/zh_CN/latest/index.html

## NumD

出自书中的第四章，如下：

```
```

需要将其与之前翻译的Lambda表达式联系，其表达自然数的方式与Lambda表达式如出一辙。

补充。


## PizzaD 

出自书中的第六章，如下：


```
//比萨饼
abstract class PizzaD { 

    //去除比萨饼中的凤尾鱼顶料(因为太咸了)
    abstract PizzaD remA(); 
    
    //在凤尾鱼顶料上加上奶酪顶料(这样会盖住凤尾鱼的咸味)
    abstract PizzaD topAwC(); 
    
    //将所有的凤尾鱼顶料换成奶酪顶料
    abstract PizzaD subAbC(); 
}

// 面包皮，注意与其他顶料在构造函数，以及实现上的区别
class Crust extends PizzaD { 
    PizzaD subAbC(){
        return new Crust();
    }
    PizzaD topAwC(){
        return new Crust();
    }
    PizzaD subAbC(){
        return new Crust();
    }
}

// 下面是各种顶料
class Cheese extends PizzaD { //奶酪
    PizzaD p;
    Cheese (PizzaD _p) {
        p = _p;
    }
    PizzaD remA(){
        return new Cheese(p.remA());
    }
    PizzaD topAwC(){
        return new Cheese(p.topAwC());
    }
    PizzaD subAbC(){
        return new Cheese(p.subAbC());
    }
}

// 橄榄
class Olive extends PizzaD { 
    PizzaD p;
    Olive (PizzaD _p) {
        p = _p;
    }
    PizzaD remA(){
        return new Olive(p.remA());
    }
    PizzaD topAwC(){
        return new Olive(p.topAwC());
    }
    PizzaD subAbC(){
        return new Olive(p.subAbC());
    }
}

// 凤尾鱼
class Anchovy extends PizzaD { 
    PizzaD p;
    Anchovy (PizzaD _p) {
        p = _p;
    }
    PizzaD remA(){
        return p.remA();
    }
    PizzaD topAwC(){
        return new Cheese(new Anchovy(p.topAwC()));
    }
    PizzaD subAbC(){
        return new Cheese(p.subAbC());
    }
}

// 香肠
class Sausage extends PizzaD { 
    PizzaD p;
    Sausage (PizzaD _p) {
        p = _p;
    }
    PizzaD remA(){
        return new Sausage(p.remA());
    }
    PizzaD topAwC(){
        return new Sausage(p.topAwC());
    }
    PizzaD subAbC(){
        return new Sausage(p.subAbC());
    }
}
```

这个例子的编程方法，很违反通常的“OOP”编程模式，很不“自然”，不太容易理解“意图”，
 通过下面的用例，可以更容易看出其设计思想：


```
public static void main(String[] args) {
	// 创建奶酪pizza
	PizzaD p0 = new Cheese(new Crust());

	// 创建凤尾鱼-奶酪pizza
	PizzaD p1 = new Anchovy(new Cheese(new Crust()));
	// 等于new Cheese(new Crust())
	p1.remA(); 

	// 创建香肠-奶酪pizza
	PizzaD p2 = new Sausage(new Cheese(new Crust()));
	
	// 等于new Sausage(new Cheese(new Crust()))
	p2.remA(); 
}
```

这种设计方法其实更函数式化编程，在三个方法的实现中，利用“构造函数”实现了“递归迭代”的思想。比如remA方法，调用它的时候会“向上遍历”所有的“pizzaD”类型实例，并调用其remA方法。

<blockquote>
一个小技巧：平时看源码的时候，如果对某一段代码不甚理解，不妨“刻意地暂时忘记改源码的实现，完全按照自己的思路实现同样功能，只需要写出“大概伪码思路”即可，然后，两相对比，通常就比较明了作者的设计思路了。
</blockquote>

同样的功能，通常的OOP实现方式如下：

```
class PizzaD { //比萨饼

	private List<PizzaMaterial> materials = new ArrayList<>();

	public PizzaD addMaterial() {

	}
	
	// 去除比萨饼中的凤尾鱼顶料(因为太咸了)
    public PizzaD remA(PizzaMaterial material) {
    	this.materials.add(material);
    }

     // 在凤尾鱼顶料上加上奶酪顶料(这样会盖住凤尾鱼的咸味)
    public PizzaD topAwC() {

    }

    // 将所有的凤尾鱼顶料换成奶酪顶料
    public PizzaD subAbC() {

    }
}

abstract class PizzaMaterial {
	// ...
}

class Crust extends PizzaMaterial { //面包皮
    // ...
}

// 下面是各种顶料
class Cheese { //奶酪
    PizzaD p;
    Cheese (PizzaD _p) {
        p = _p;
    }
    
}

class Olive extends PizzaD { //橄榄
    PizzaD p;
    Olive (PizzaD _p) {
        p = _p;
    }
    
}

class Anchovy extends PizzaD { //凤尾鱼
    PizzaD p;
    Anchovy (PizzaD _p) {
        p = _p;
    }
    
}

class Sausage extends PizzaD { //香肠
    PizzaD p;
    Sausage (PizzaD _p) {
        p = _p;
    }
    
}
```

